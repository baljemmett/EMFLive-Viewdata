#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use Time::Local qw(timelocal_posix);

use ScheduleReader;
use TelstarFrame;

###
# Various settings and suchlike
###

# Which year are we in, and where's the schedule file?
my $year     = 2022;
my $filename = "$year.json";

$TelstarFrame::service = "[R][n][C] EMF ${year}[W]Live   [-]";
$TelstarFrame::directory = "newframes";

###
#   Main body of script
###
my $force_time = undef;

GetOptions("file=s" => \$filename,
           "time=s" => \$force_time)
or die "Error in command line arguments.";

# Find current time, but allow it to be partially overridden by command line.
my $now = time();
if (defined $force_time)
{
    my @fake_now = localtime();
    my @parts = split /[-: ]+/, $force_time;

    # @fake_now contains, in order:
    # sec min hour day mon year weekday yearday isdst
    # @parts contains some prefix of:
    # year mon day hour min sec

    $fake_now[5] = shift(@parts) - 1900 if @parts;
    $fake_now[4] = shift(@parts) - 1 if @parts;
    $fake_now[3] = shift @parts if @parts;
    $fake_now[2] = shift @parts if @parts;
    $fake_now[1] = shift @parts if @parts;
    $fake_now[0] = shift @parts if @parts;

    $now = timelocal_posix(@fake_now);
}

# ScheduleReader gives us the events in chronological order 
my @events = ScheduleReader::from_file($filename);

print "Generating Now and Next details as of ", scalar localtime($now), ".\n";

my %venues = ();

for my $event (@events)
{
	# Currently in between the start and end times? It's on now!
    if ($event->{stime} <= $now && $now <= $event->{etime})
    {
        $venues{$event->{venue}}{now} = $event;
    }

	# In the future and for a venue we don't already know the next event for?
	# It must be the next event for that venue.
    elsif ($event->{stime} > $now && ! exists $venues{$event->{venue}}{next})
    {
        $venues{$event->{venue}}{next} = $event;
    }
}

print "Now:\n";
for my $venue (sort keys %venues)
{
    next if ! exists $venues{$venue}{now};
    my $event = $venues{$venue}{now};
    printf "%4d  %s - %s %-20s %s\n", $event->{id}, $event->{"start"}, $event->{"end"}, $event->{venue}, $event->{title};
}

print "\nNext:\n";
for my $venue (sort keys %venues)
{
    next if ! exists $venues{$venue}{next};
    my $event = $venues{$venue}{next};
    printf "%4d  %s - %s %-20s %s\n", $event->{id}, $event->{"start"}, $event->{"end"}, $event->{venue}, $event->{title};
}