#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;
use Time::Local qw(timelocal_posix);
use POSIX qw(strftime);

use ScheduleReader;
use TelstarFrame;
use Paginator;
use Text::Wrapper;

###
# Various settings and suchlike
###

# Which year are we in, and where's the schedule file?
my $year     = 2022;
my $filename = "$year.json";

$TelstarFrame::service = "[R][n][C] EMF ${year}[W]Live   [-]";
$TelstarFrame::directory = "newframes";

###
#   Main body of script
###
my $force_time = undef;

GetOptions("file=s" => \$filename,
           "time=s" => \$force_time)
or die "Error in command line arguments.";

# Find current time, but allow it to be partially overridden by command line.
my $now = time();
if (defined $force_time)
{
    my @fake_now = localtime();
    my @parts = split /[-: ]+/, $force_time;

    # @fake_now contains, in order:
    # sec min hour day mon year weekday yearday isdst
    # @parts contains some prefix of:
    # year mon day hour min sec

    $fake_now[5] = shift(@parts) - 1900 if @parts;
    $fake_now[4] = shift(@parts) - 1 if @parts;
    $fake_now[3] = shift @parts if @parts;
    $fake_now[2] = shift @parts if @parts;
    $fake_now[1] = shift @parts if @parts;
    $fake_now[0] = shift @parts if @parts;

    $now = timelocal_posix(@fake_now);
}

# ScheduleReader gives us the events in chronological order 
my @events = ScheduleReader::from_file($filename);

print "Generating Now and Next details as of ", scalar localtime($now), ".\n";

my $updated = strftime("%a %H:%M", localtime($now));

my %venues = ();

for my $event (@events)
{
	# Currently in between the start and end times? It's on now!
    if ($event->{stime} <= $now && $now <= $event->{etime})
    {
        $venues{$event->{venue}}{now} = $event;
    }

	# In the future and for a venue we don't already know the next event for?
	# It must be the next event for that venue.
    elsif ($event->{stime} > $now && ! exists $venues{$event->{venue}}{next})
    {
        $venues{$event->{venue}}{next} = $event;
    }
}

print "Now:\n";
for my $venue (sort keys %venues)
{
    next if ! exists $venues{$venue}{now};
    my $event = $venues{$venue}{now};
    printf "%4d  %s - %s %-20s %s\n", $event->{id}, $event->{"start"}, $event->{"end"}, $event->{venue}, $event->{title};
}

print "\nNext:\n";
for my $venue (sort keys %venues)
{
    next if ! exists $venues{$venue}{next};
    my $event = $venues{$venue}{next};
    printf "%4d  %s - %s %-20s %s\n", $event->{id}, $event->{"start"}, $event->{"end"}, $event->{venue}, $event->{title};
}

sub generate_list
{
    my ($events_by_venue, $root, $event_root, @venues) = @_;

	my $frame = new TelstarFrame($root);
	my $paginator = new Paginator($frame, {
        header    => [],
        continues => "",
        continued => "",
    });
	my $wrapper = Text::Wrapper->new(columns => 38);

	for my $venue (@venues)
	{
        my $key = 0;

        $paginator->add_text_block(
            "[R][n][D][Y]NOW AND NEXT:[W]$venue",
            "",
        );

        for my $which (qw(now next))
        {
            $key++;

            if (! exists $events_by_venue->{$venue}{$which})
            {
                $paginator->add_text_block(
                    "",
                    "[B][n][Y] ON \U$which\E:",
                    "",
                    "[C]No event scheduled.",
                );

                next;
            }

            my $event = $events_by_venue->{$venue}{$which};
            my $entry_frame = ($event_root * 1000) + $event->{id};

            $paginator->add_text_block(
                "",
                "[B][n][Y] ON \U$which\E: press[W]${key}[Y]for details",
            );

            # Build the index entry for this event
#           my $schedule_line = "[C]$event->{start} - $event->{end}   $event->{venue}";
            my $schedule_line = "[C]$event->{start} - $event->{end}";
            my @wrapped_title = split /\n/, $wrapper->wrap($event->{title});
            my @wrapped_by    = split /\n/, $wrapper->wrap("$event->{type} by " . $event->{by});

            my $wrapped_first = shift @wrapped_by;
            $wrapped_first =~ s/ by / by[C]/;
            
            my @entry = ();
            push @entry, "";
            push @entry, $schedule_line;
            push @entry, map "[Y]$_", @wrapped_title;
            push @entry, "[W]$wrapped_first";
            push @entry, map "[C]$_", @wrapped_by;

            $paginator->add_text_block(@entry);
            $paginator->frame->set_route($key, $entry_frame);
		}

        my $blanks = 21 - $paginator->frame->count_lines();
        $paginator->add_text_block(
            map("", 1..$blanks),
            sprintf("%40s", "[W]Updated " . $updated),
        );

		$paginator->new_page();
    }
}

generate_list(\%venues, 401, 300, "Stage A");
generate_list(\%venues, 402, 300, "Stage B");
generate_list(\%venues, 403, 300, "Stage C");
generate_list(\%venues, 404, 300, sort grep /Workshop/, keys %venues);
generate_list(\%venues, 405, 300, sort grep /Sector/, keys %venues);
generate_list(\%venues, 406, 300, sort grep !/Stage|Workshop|Sector/, keys %venues);
generate_list(\%venues, 407, 300, sort grep /Stage/, keys %venues);
generate_list(\%venues, 409, 300, sort keys %venues);